<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Relay Inspector</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
    }
    h1 { color: #ff79c6; margin-bottom: 20px; }
    .form-group { margin-bottom: 15px; }
    label { display: block; margin-bottom: 5px; color: #bd93f9; }
    input, textarea, select {
      width: 100%;
      padding: 10px;
      border: 1px solid #44475a;
      border-radius: 4px;
      background: #282a36;
      color: #f8f8f2;
      font-family: monospace;
    }
    input:focus, textarea:focus { outline: none; border-color: #ff79c6; }
    button {
      background: #ff79c6;
      color: #282a36;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      margin-right: 10px;
    }
    button:hover { background: #ff92d0; }
    button:disabled { background: #6272a4; cursor: not-allowed; }
    .output {
      margin-top: 20px;
      background: #282a36;
      border: 1px solid #44475a;
      border-radius: 4px;
      padding: 15px;
      overflow-x: auto;
    }
    pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-all;
      font-size: 12px;
      line-height: 1.5;
    }
    .tree-view {
      font-family: monospace;
      font-size: 13px;
      line-height: 1.6;
      white-space: pre;
      color: #f8f8f2;
    }
    .tree-kind { color: #ff79c6; font-weight: bold; }
    .tree-event { color: #8be9fd; }
    .tree-tag { color: #50fa7b; }
    .tree-value { color: #f1fa8c; }
    .tree-content { color: #bd93f9; }
    .tree-empty { color: #6272a4; font-style: italic; }
    .status { color: #50fa7b; margin-bottom: 10px; }
    .error { color: #ff5555; }
    .info { color: #8be9fd; font-size: 12px; margin-top: 5px; }
    .presets { margin-bottom: 20px; }
    .presets button { background: #6272a4; margin-bottom: 5px; }
    .presets button:hover { background: #7c8db5; }
    .row { display: flex; gap: 15px; }
    .row .form-group { flex: 1; }
    .tag-info { background: #44475a; padding: 10px; border-radius: 4px; margin-top: 10px; font-size: 12px; }
    .summary { background: #44475a; padding: 15px; border-radius: 4px; margin-bottom: 15px; }
    .summary h3 { margin: 0 0 10px 0; color: #ff79c6; }
    .summary-item { margin: 5px 0; }
    .copy-btn { background: #6272a4; font-size: 12px; padding: 5px 10px; }
    .view-toggle { margin-top: 10px; }
    .view-toggle button { background: #6272a4; margin-right: 5px; }
    .view-toggle button.active { background: #ff79c6; }
  </style>
</head>
<body>
  <h1>üîç Relay Inspector</h1>

  <div class="presets">
    <strong>Presets:</strong><br>
    <button onclick="loadPreset('allnip51')">All NIP-51 Lists</button>
    <button onclick="loadPreset('follows')">Follows (kind:3)</button>
    <button onclick="loadPreset('mutes')">Mutes (kind:10000)</button>
    <button onclick="loadPreset('bookmarks')">Bookmarks OLD (kind:10003)</button>
    <button onclick="loadPreset('bookmarksets')">Bookmark Sets (kind:30003)</button>
    <button onclick="loadPreset('tribes')">Tribes (kind:30000)</button>
    <button onclick="loadPreset('profile')">Profile (kind:0)</button>
    <button onclick="loadPreset('relaylist')">Relay List (kind:10002)</button>
  </div>

  <div class="form-group">
    <label>Relay URLs (one per line)</label>
    <textarea id="relays" rows="4">wss://relay.damus.io
wss://nos.lol
wss://relay.nostr.band
wss://purplepag.es</textarea>
  </div>

  <div class="row">
    <div class="form-group">
      <label>Author Pubkey (npub oder hex)</label>
      <input type="text" id="pubkey" placeholder="npub1... oder hex">
      <div class="info">Leave empty to query all authors</div>
    </div>
    <div class="form-group">
      <label>Event Kinds (comma-separated)</label>
      <input type="text" id="kinds" value="10003" placeholder="e.g. 1,3,10000">
    </div>
    <div class="form-group">
      <label>Limit</label>
      <input type="number" id="limit" value="5" min="1" max="100">
    </div>
  </div>

  <div class="form-group">
    <label>Additional Filter (JSON, optional)</label>
    <input type="text" id="extraFilter" placeholder='e.g. {"#e": ["eventid..."]}'>
  </div>

  <button id="fetchBtn" onclick="fetchEvents()">Fetch Events</button>
  <button onclick="clearOutput()">Clear</button>

  <div class="output">
    <div id="status" class="status"></div>
    <div id="summary"></div>
    <div class="view-toggle" id="viewToggle" style="display:none;">
      <button id="jsonViewBtn" class="active" onclick="switchView('json')">JSON View</button>
      <button id="treeViewBtn" onclick="switchView('tree')">Tree View</button>
    </div>
    <pre id="result">Results will appear here...</pre>
  </div>

  <div class="tag-info">
    <strong>Common NIP-51 Tag Types:</strong><br>
    <code>p</code> = pubkey (follows, mutes) |
    <code>e</code> = event ID (bookmarks, muted threads) |
    <code>a</code> = article reference |
    <code>t</code> = hashtag |
    <code>r</code> = URL |
    <code>word</code> = muted word |
    <code>d</code> = identifier (parameterized replaceable events)
  </div>

  <script>
    // Bech32 decoding for npub
    const BECH32_ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';

    function bech32Decode(str) {
      const lowered = str.toLowerCase();
      let pos = lowered.lastIndexOf('1');
      if (pos < 1 || pos + 7 > lowered.length) throw new Error('Invalid bech32');

      const prefix = lowered.slice(0, pos);
      const data = [];
      for (let i = pos + 1; i < lowered.length; i++) {
        const c = BECH32_ALPHABET.indexOf(lowered[i]);
        if (c === -1) throw new Error('Invalid bech32 character');
        data.push(c);
      }

      // Remove checksum (last 6 chars)
      const words = data.slice(0, -6);

      // Convert 5-bit words to 8-bit bytes
      let bits = 0;
      let value = 0;
      const bytes = [];
      for (const word of words) {
        value = (value << 5) | word;
        bits += 5;
        while (bits >= 8) {
          bits -= 8;
          bytes.push((value >> bits) & 0xff);
        }
      }

      return { prefix, bytes };
    }

    function npubToHex(npub) {
      if (!npub.startsWith('npub1')) throw new Error('Not an npub');
      const { bytes } = bech32Decode(npub);
      return bytes.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function resolvePubkey(input) {
      if (!input) return null;
      if (input.startsWith('npub1')) {
        try {
          return npubToHex(input);
        } catch (e) {
          throw new Error('Invalid npub: ' + e.message);
        }
      }
      // Assume hex
      if (/^[0-9a-fA-F]{64}$/.test(input)) {
        return input.toLowerCase();
      }
      throw new Error('Invalid pubkey format (must be npub1... or 64 char hex)');
    }

    const DEFAULT_RELAYS = [
      'wss://relay.damus.io',
      'wss://nos.lol',
      'wss://relay.nostr.band',
      'wss://purplepag.es'
    ];

    const NIP51_KINDS = {
      10000: 'Mute List',
      10001: 'Pin List',
      30000: 'Follow Sets / Tribes',
      30001: 'Generic Lists',
      30002: 'Relay Sets',
      30003: 'Bookmark Sets',
      30004: 'Curation Sets',
      30005: 'Interest Sets',
      30015: 'Interest Sets (alt)',
      30030: 'Emoji Sets'
    };

    function loadPreset(type) {
      const presets = {
        allnip51: { kinds: '10000,10001,30000,30001,30002,30003,30004,30005,30015,30030', limit: 100 },
        follows: { kinds: '3', limit: 1 },
        mutes: { kinds: '10000', limit: 1 },
        bookmarks: { kinds: '10003', limit: 1 },
        bookmarksets: { kinds: '30003', limit: 20 },
        tribes: { kinds: '30000', limit: 50 },
        profile: { kinds: '0', limit: 1 },
        relaylist: { kinds: '10002', limit: 1 }
      };
      const p = presets[type];
      document.getElementById('kinds').value = p.kinds;
      document.getElementById('limit').value = p.limit;
    }

    function setStatus(msg, isError = false) {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.className = isError ? 'status error' : 'status';
    }

    function clearOutput() {
      document.getElementById('result').textContent = 'Results will appear here...';
      document.getElementById('status').textContent = '';
      document.getElementById('summary').innerHTML = '';
      document.getElementById('viewToggle').style.display = 'none';
      currentView = 'json';
      currentData = null;
    }

    let currentView = 'json';
    let currentData = null;

    function switchView(view) {
      if (!currentData) return;
      currentView = view;

      document.getElementById('jsonViewBtn').classList.toggle('active', view === 'json');
      document.getElementById('treeViewBtn').classList.toggle('active', view === 'tree');

      const resultEl = document.getElementById('result');
      if (view === 'json') {
        resultEl.className = '';
        resultEl.textContent = JSON.stringify(currentData, null, 2);
      } else {
        resultEl.className = 'tree-view';
        resultEl.innerHTML = buildTreeView(currentData);
      }
    }

    function buildTreeView(data) {
      if (!data.events || data.events.length === 0) {
        return '<span class="tree-empty">No events found</span>';
      }

      // Group events by kind
      const eventsByKind = {};
      data.events.forEach(event => {
        if (!eventsByKind[event.kind]) {
          eventsByKind[event.kind] = [];
        }
        eventsByKind[event.kind].push(event);
      });

      let tree = '';
      tree += `<span class="tree-kind">NIP-51 Lists Overview (${data.totalEvents} events)</span>\n`;
      tree += '‚îÇ\n';

      const kinds = Object.keys(eventsByKind).sort((a, b) => parseInt(a) - parseInt(b));
      kinds.forEach((kind, kindIdx) => {
        const isLastKind = kindIdx === kinds.length - 1;
        const kindPrefix = isLastKind ? '‚îî‚îÄ' : '‚îú‚îÄ';
        const childPrefix = isLastKind ? '  ' : '‚îÇ ';

        const kindName = NIP51_KINDS[kind] || `Kind ${kind}`;
        const events = eventsByKind[kind];

        tree += `${kindPrefix} <span class="tree-kind">${kindName} (kind:${kind})</span> - ${events.length} event(s)\n`;

        events.forEach((event, eventIdx) => {
          const isLastEvent = eventIdx === events.length - 1;
          const eventPrefix = isLastEvent ? '‚îî‚îÄ' : '‚îú‚îÄ';
          const eventChildPrefix = isLastEvent ? '  ' : '‚îÇ ';

          // Get d-tag for parameterized replaceable events
          const dTag = event.tags.find(t => t[0] === 'd');
          const dValue = dTag ? dTag[1] : null;
          const titleTag = event.tags.find(t => t[0] === 'title');
          const title = titleTag ? titleTag[1] : null;

          const eventLabel = dValue !== null
            ? `<span class="tree-value">d:"${dValue}"</span>${title && title !== dValue ? ` (${title})` : ''}`
            : `Event ${event.id.slice(0, 8)}...`;

          const timestamp = new Date(event.created_at * 1000).toLocaleString('de-DE');
          tree += `${childPrefix}${eventPrefix} <span class="tree-event">${eventLabel}</span> - ${timestamp}\n`;

          // Count tags by type
          const tagCounts = {};
          event.tags.forEach(tag => {
            const type = tag[0];
            if (type !== 'd' && type !== 'title' && type !== 'client') {
              tagCounts[type] = (tagCounts[type] || 0) + 1;
            }
          });

          // Show tag counts
          const tagTypes = Object.keys(tagCounts).sort();
          if (tagTypes.length > 0) {
            tree += `${childPrefix}${eventChildPrefix}‚îú‚îÄ <span class="tree-tag">Tags:</span> `;
            tree += tagTypes.map(t => `<span class="tree-value">${t}:${tagCounts[t]}</span>`).join(', ');
            tree += '\n';
          }

          // Show content if present
          if (event.content && event.content.trim() !== '') {
            const contentPreview = event.content.length > 60
              ? event.content.slice(0, 60) + '...'
              : event.content;
            tree += `${childPrefix}${eventChildPrefix}‚îú‚îÄ <span class="tree-content">Content:</span> ${event.content.length} chars`;
            if (event.content.length < 100) {
              tree += ` - "${contentPreview}"`;
            }
            tree += '\n';
          }

          // Show relay source
          tree += `${childPrefix}${eventChildPrefix}‚îî‚îÄ <span class="tree-tag">From:</span> ${event._fromRelay.replace('wss://', '')}\n`;
        });

        if (!isLastKind) tree += '‚îÇ\n';
      });

      return tree;
    }

    async function fetchEvents() {
      const btn = document.getElementById('fetchBtn');
      btn.disabled = true;

      const relaysText = document.getElementById('relays').value;
      const relays = relaysText.split('\n').map(r => r.trim()).filter(r => r.startsWith('wss://'));

      let pubkey = null;
      const pubkeyInput = document.getElementById('pubkey').value.trim();
      if (pubkeyInput) {
        try {
          pubkey = resolvePubkey(pubkeyInput);
        } catch (e) {
          setStatus(e.message, true);
          btn.disabled = false;
          return;
        }
      }
      const kindsText = document.getElementById('kinds').value;
      const kinds = kindsText.split(',').map(k => parseInt(k.trim())).filter(k => !isNaN(k));
      const limit = parseInt(document.getElementById('limit').value) || 5;
      const extraFilterText = document.getElementById('extraFilter').value.trim();

      let extraFilter = {};
      if (extraFilterText) {
        try {
          extraFilter = JSON.parse(extraFilterText);
        } catch (e) {
          setStatus('Invalid extra filter JSON: ' + e.message, true);
          btn.disabled = false;
          return;
        }
      }

      if (relays.length === 0) {
        setStatus('No valid relay URLs', true);
        btn.disabled = false;
        return;
      }

      if (kinds.length === 0) {
        setStatus('No valid kinds', true);
        btn.disabled = false;
        return;
      }

      const filter = { kinds, limit, ...extraFilter };
      if (pubkey) {
        filter.authors = [pubkey];
      }

      setStatus(`Connecting to ${relays.length} relays...`);

      const allEvents = new Map();
      const relayResults = {};
      let completed = 0;

      const timeout = 8000;

      await Promise.all(relays.map(relayUrl => {
        return new Promise((resolve) => {
          relayResults[relayUrl] = { status: 'connecting', events: 0 };

          try {
            const ws = new WebSocket(relayUrl);
            const subId = 'inspector-' + Math.random().toString(36).slice(2, 8);
            let resolved = false;

            const timeoutId = setTimeout(() => {
              if (!resolved) {
                resolved = true;
                relayResults[relayUrl].status = 'timeout';
                ws.close();
                resolve();
              }
            }, timeout);

            ws.onopen = () => {
              relayResults[relayUrl].status = 'connected';
              ws.send(JSON.stringify(['REQ', subId, filter]));
              updateStatus();
            };

            ws.onmessage = (msg) => {
              try {
                const data = JSON.parse(msg.data);
                if (data[0] === 'EVENT' && data[2]) {
                  const event = data[2];
                  allEvents.set(event.id, { event, relay: relayUrl });
                  relayResults[relayUrl].events++;
                  updateStatus();
                } else if (data[0] === 'EOSE') {
                  relayResults[relayUrl].status = 'done';
                  clearTimeout(timeoutId);
                  ws.close();
                  if (!resolved) {
                    resolved = true;
                    resolve();
                  }
                } else if (data[0] === 'NOTICE') {
                  console.log('NOTICE from', relayUrl, data[1]);
                }
              } catch (e) {}
            };

            ws.onerror = () => {
              relayResults[relayUrl].status = 'error';
              clearTimeout(timeoutId);
              if (!resolved) {
                resolved = true;
                resolve();
              }
            };

            ws.onclose = () => {
              clearTimeout(timeoutId);
              if (!resolved) {
                resolved = true;
                resolve();
              }
            };
          } catch (e) {
            relayResults[relayUrl].status = 'error';
            resolve();
          }
        });
      }));

      function updateStatus() {
        const statusParts = Object.entries(relayResults).map(([url, r]) => {
          const shortUrl = url.replace('wss://', '').split('/')[0];
          return `${shortUrl}: ${r.status} (${r.events})`;
        });
        setStatus(statusParts.join(' | '));
      }

      updateStatus();

      // Sort by created_at desc
      const events = Array.from(allEvents.values())
        .sort((a, b) => b.event.created_at - a.event.created_at);

      // Build summary
      let summaryHtml = '';
      if (events.length > 0) {
        const latestEvent = events[0].event;
        const tagCounts = {};
        latestEvent.tags.forEach(tag => {
          const type = tag[0];
          tagCounts[type] = (tagCounts[type] || 0) + 1;
        });

        summaryHtml = `
          <div class="summary">
            <h3>Latest Event Summary</h3>
            <div class="summary-item"><strong>Kind:</strong> ${latestEvent.kind}</div>
            <div class="summary-item"><strong>Created:</strong> ${new Date(latestEvent.created_at * 1000).toLocaleString()}</div>
            <div class="summary-item"><strong>Total Tags:</strong> ${latestEvent.tags.length}</div>
            <div class="summary-item"><strong>Tag Types:</strong> ${Object.entries(tagCounts).map(([k,v]) => `${k}:${v}`).join(', ') || 'none'}</div>
            <div class="summary-item"><strong>Content:</strong> ${latestEvent.content ? (latestEvent.content.length > 50 ? latestEvent.content.slice(0, 50) + '... (' + latestEvent.content.length + ' chars)' : latestEvent.content) : '(empty)'}</div>
            <div class="summary-item"><strong>Event ID:</strong> <code>${latestEvent.id}</code></div>
            <button class="copy-btn" onclick="copyToClipboard('${latestEvent.id}')">Copy ID</button>
            <button class="copy-btn" onclick="copyEventJson()">Copy Full JSON</button>
          </div>
        `;
      }
      document.getElementById('summary').innerHTML = summaryHtml;

      // Format output
      const output = {
        query: { filter, relays },
        relayStatus: relayResults,
        totalEvents: events.length,
        events: events.map(e => ({
          ...e.event,
          _fromRelay: e.relay,
          _createdAtHuman: new Date(e.event.created_at * 1000).toISOString()
        }))
      };

      currentData = output;
      document.getElementById('viewToggle').style.display = 'block';
      switchView('tree'); // Default to tree view for NIP-51 lists
      btn.disabled = false;
    }

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text);
    }

    function copyEventJson() {
      const result = document.getElementById('result').textContent;
      try {
        const data = JSON.parse(result);
        if (data.events) {
          navigator.clipboard.writeText(JSON.stringify(data.events, null, 2));
        }
      } catch (e) {}
    }

    // Try to load pubkey from localStorage
    try {
      const stored = localStorage.getItem('noornote_auth_state');
      if (stored) {
        const auth = JSON.parse(stored);
        if (auth.pubkey) {
          document.getElementById('pubkey').value = auth.pubkey;
        }
      }
    } catch (e) {}
  </script>
</body>
</html>
